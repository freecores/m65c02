header
Project: M65C02_uP_ROM
File Revision: 0020
Author(s): Michael A. Morris
Description: M65C02 Microprogram
endh

--------------------------------------------------------------------------------
--
--  Copyright 2011-2012 by Michael A. Morris, dba M. A. Morris & Associates
--
--  All rights reserved. The source code contained herein is publicly released
--  under the terms and conditions of the GNU Lesser Public License. No part of
--  this source code may be reproduced or transmitted in any form or by any
--  means, electronic or mechanical, including photocopying, recording, or any
--  information storage and retrieval system in violation of the license under
--  which the source code is released.
--
--  The source code contained herein is free; it may be redistributed and/or
--  modified in accordance with the terms of the GNU Lesser General Public
--  License as published by the Free Software Foundation; either version 2.1 of
--  the GNU Lesser General Public License, or any later version.
--
--  The source code contained herein is freely released WITHOUT ANY WARRANTY;
--  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
--  PARTICULAR PURPOSE. (Refer to the GNU Lesser General Public License for
--  more details.)
--
--  A copy of the GNU Lesser General Public License should have been received
--  along with the source code contained herein; if not, a copy can be obtained
--  by writing to:
--
--  Free Software Foundation, Inc.
--  51 Franklin Street, Fifth Floor
--  Boston, MA  02110-1301 USA
--
--  Further, no use of this source code is permitted in any form or means
--  without inclusion of this banner prominently in any derived works.
--
--  Michael A. Morris
--  Huntsville, AL
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Revision History:
--------------------------------------------------------------------------------
--
--  0001    11D09   mam     Initial development.
--
--  0002    11D17   mam     Continued development.
--
--  0003    12A21   mam     Continued development, added En_PC field, removed
--                          Bus Interface Unit (BIU) and Program Control Unit
--                          (PCU) control fields and changed Memory Data Output
--                          field to Memory Data Output/Input Field. The BIU and
--                          PCU concepts deemed to complex for this implementa-
--                          tion. Implementation now relies on direct control of
--                          the bus cycles by the microprogram. Conditional exe-
--                          cution of most branches is now used to allow the uP
--                          execution to be controlled by the test signals. this
--                          allows tighter and faster uPgms, and facilitates the
--                          implementation of the uPgm.
--
--  0004    12A22   mam     Completed development of the MAM6502 microprogram.
--                          Added comments below regarding the implementation of
--                          the conditional branches discussed in note 0003. No
--                          attempt is made to minimize the number or length of
--                          the microroutines. Only five instructions are used,
--                          and no subroutines are used. Several direct address-
--                          microroutines are equivalent. Since several of these
--                          addressing modes yield the same effective address,
--                          they could be combined, but it is unlikely to save
--                          enough to allow the branch address field and MPC
--                          address register to be decreased from 8 to 7 bits.
--
--  0005    12B07   mam     Completed the restructing of the microprogram. the
--                          basic structure remains the same. However, issues
--                          related to the pipelining of the instruction decode
--                          (fixed microword) have been corrected by incorpora-
--                          ting a instruction decode ROM directly into the uP
--                          ROM itself. This corrects the primary issue which is
--                          that the first microword of each instruction se-
--                          quence needed to be specific for each instruction or
--                          addressing mode. With the previous architecture, too
--                          much special handling logic was needed to ensure
--                          proper execution of individual instructions. The
--                          special logic needed was proving to be difficult to
--                          implement, and thus violating the primary motivation
--                          for the development of the control unit as a micro-
--                          programmed state machine. With the new structure,
--                          the first microword on the control unit is deter-
--                          simultaneously with the look-up in the instruction
--                          decoder ROM of the fixed instruction microword. The
--                          format of the Instruction Decode ROM has been sim-
--                          plified, and the actual opcode embedded in the
--                          fixed microword in order to preserve a width of 32
--                          for this ROM and that of the variable microwords. If
--                          this field is left out, since its contents matches
--                          the input, then the total amount of microwords (var
--                          plus fixed) is 32 + 24 = 56 bits. The two level,
--                          i.e. fixed and variable microcode, will be main-
--                          tained because the 24 bits of the fixed microword is
--                          required until the control unit indicates that the
--                          instruction is ready to execute, i.e. enable ALU.
--                          The final major change was that the specific modifi-
--                          cations to many of the branching instructions of the
--                          MAM6502_MPC (based on the F9408A_MPC) have been un-
--                          done, and conditional execution applied, under con-
--                          trol of control field in the variable microword, to
--                          all instructions of the MPC. This allows the micro-
--                          programmed state machine, i.e. control unit, to be
--                          responsible for the synchronization and capture of
--                          external data. The automatic cycle wait delay that
--                          is now built in for all MPC instructions, can be
--                          automatically performed if the microprogram allows
--                          it explicitly, or it can simply use multiple states
--                          to implement the required timing and external bus
--                          synchronization. Finally, the external memory was
--                          defined as a LUT RAM. This means that data reads and
--                          data writes are single clock cycle operations. The
--                          Rdy cycle completion signal will stretch the control
--                          unit operations dependent on the external memory. If
--                          needed, additional logic can be added, and the con-
--                          trol unit should execute instructions as required.
--
--  0006    12B16   MAM     Completed checkout of the basic instructions and
--                          addressing modes: Jumps, Branches, push/pop, all
--                          alu operations with immediate operands, acc modes
--                          instructions, all flag set/clear instructions, and
--                          all other implied operand instructions except BRK.
--                          Optimized microroutines to eliminate state redundant
--                          with _Nxt (Fetch/Execute) state. This eliminates the
--                          second state of Push/Pop instructions, all immediate
--                          operand instructions, and all branches. Labels moved
--                          and grouped with the _Nxt label as a reminder that
--                          this optimization is included.
--
--  0007    12B19   MAM     Added missing instruction: STZ dp,X
--
--  0008    12B20   MAM     Reworked the _Int and _Brk microroutines. Added the
--                          ISR strobe to the third cycle, i.e. Push P state, to
--                          explicitly clear D and set I before start of inter-
--                          rupt/trap service routine.
--
--  0009    12B22   MAM     Added limited support for interrupt handling at spe-
--                          cific instruction boundaries. The Branch Multi-Way
--                          MPC instruction is used in the last state of each
--                          microroutine to sample the external Int signal. the
--                          configuration of the _Nxt and _Int microstates form
--                          a 2-way branch table. The last state in a micro-
--                          routine points to this 2-way table, and if the Int
--                          signal is asserted, then the _Int microroutine is
--                          executed, otherwise the normal instruction fetch
--                          and decode of the next instruction is performed by
--                          the BRV1 instruction at _Nxt.
--
--  0010    12B23   MAM     Completed conversion of the microcode for the other
--                          instruction groups, except the RMW groups, to sup-
--                          port interrupts. Due to the overlapped nature of the
--                          fetch and execute, the first microstate in _Int was
--                          set to signal Done. In this way while PCH is being
--                          pushed, the instruction is being executed. A problem
--                          still remains in how to deal with the extra cycle
--                          required to complete ADC/SBC in BCD mode. The BCD
--                          adder requires an extra cycle to complete adjustment
--                          of the two BCD digits following the initial binary
--                          sum.
--
--  0011    12B24   MAM     Changed microprogram for CLI/SEI so that they are
--                          interruptable. That is, if IRQ/NMI is asserted when
--                          these instructions enable/disable interrupts, then
--                          the trap will not be taken until the completion of
--                          instruction which follows. (BCD operations issue
--                          rectified in change made to M65C02_Core/M65C02_ALU
--                          modules.)
--
--  0012    12B25   MAM     Added WE_R to _Int microstate to allow instruction
--                          being interrupted to complete. All other elements
--                          needed to correctly interrupt an instruction made
--                          to module M65C02_Core. Added a second jump table for
--                          normal or interrupt processing of RMW instructions.
--                          _Nxt/_Int are not acceptable since they assert WE_R
--                          to allow instruction to complete while PCH is being
--                          pushed. RMW instructions have already written any
--                          registers, so a second WE_R could corrupt memory or
--                          the PSW. Thus, the BRV1 and BRV2 microstates in the
--                          RMW jump table do not assert WE_R.
--
--  0013    12C04   MAM     Made corrections to all RMW operations. Change makes
--                          the output of the ALU come out on the output data
--                          bus on the correct cycle. The ALU provides the out-
--                          put on the cycle following the read, so there's no
--                          need for a cycle to wait on ALU Valid before writing
--                          result back to memory.
--
--  0014    12D28   MAM     Corrected the _LDX_abs instruction. Improperly took
--                          branch to _RO_AbsX instead of _RO_Abs. (Notified of
--                          error by Windfall @forum.6502.org.)
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--
--  Forked from M65C02_uPgm_V3.txt when M65C02_MPCv3 started being used in the
--  core, and the original MPC was retained for use with M65C02_Base, the origi-
--  nal source file for the M65C02 processor core.
--
--  0015    12K12   MAM     Modified the microcode to remove the Wait control
--                          signal, and replace it with a ZP control signal. ZP
--                          is asserted whenever an indexed zp address mode, or
--                          an indirect indexed zero page address mode is used.
--                          For indexed zero page addressing (zp,X; zp,Y), the
--                          target location must be in page zero, i.e. % 256.
--                          For indirect indexed addressing ((zp,X); (zp),Y)),
--                          both halves of the 16-bit pointer must be located on
--                          page zero. In (zp,X), the fetch operation of the
--                          high byte of the pointer must wrap on page 0.
--
--  0016    12K17   MAM     Corrected entry for $22 from BRV1 to BRV3. removed
--                          use of {SC, Done} field in preparation for reusing
--                          the field to control the M65C02_MPCv3 microcycle
--                          length, uLen[1:0], field from within the micro-
--                          program.
--
--  0017    12K20   MAM     Changed the MemTyp field of the first microword to
--                          ensure that the first instruction fetch cycle deter-
--                          mines whether a wait state, multi-cycle microcycle
--                          is needed.
--
--  0018    12L09   MAM     Added support for WAI, STP, and indirect jumps for
--                          NMI and IRQ/BRK. Also added indirect jump for RST,
--                          but without pushes to the stack required for other
--                          exceptions.
--
--  0019    12L15   MAM     Added Rockwell instructions. RMBx/SMBx instructions
--                          use to the _RMW_DP microroutine to execute. The BBRx
--                          and BBSx instructions use a new microroutine to exe-
--                          cute: _BByx_dp_rel.
--
--  0020    13B23   MAM     Removed IF from first microword. Performs memory
--                          read cycle not required to fetch vector value from
--                          the reset vector. 
--
--------------------------------------------------------------------------------
--  Comments
--------------------------------------------------------------------------------
--
--  The microprogram controller being targeted is the F9408A MPC. That control-
--  ler provides for sequential execution (FTCH), microroutine subroutines (RTS,
--  BSR), multi0way branching (BMW), unconditional externally controlled branch-
--  ing (BRV0, BRV1, BRV2, BRV3), and conditional branching using external test
--  inputs (BTL0, BTH0, BTL1, BTH1, BTL2, BTH2, BTL3, BTH3). Past use of this
--  controller has been focused on using the FTCH, BRV0, BSR, RTS, and BTL0/BTH0
--  as the basis of control. An external multiplexer controlled by the microword
--  and tied to the T0 test pin has been used for most tests. BRV0 has been used
--  in a conventional manner, and as such, it has only been used as an uncondi-
--  tional branch to a microprogram address supplied in the microword. No extra-
--  ordinary use of these basic control structures has been attempted.
--
--  With the program and data memory of the target, the M65C02 synthesizable
--  microprocessor/microcomputer, external to the core, there is a need to
--  implement a memory interface. From an implementation perspective, the exter-
--  nal memory interface would need to supply a ready signal so that the M65C02
--  logic can capture any input data into the instruction register, IR, one of
--  the two internal temporary operand registers, OP1 and OP2, or one of the
--  programmer-visible registers of the processor core: A, X, Y, P, or S.
--
--  If the direct approach to using the F9408A MPC is maintained, a number of
--  additional clock cycles will be added to each operation. A discrete logic
--  FSM approach for the processor core controller would branch to any number of
--  multiple states as needed to minimize the total number of cycles needed to
--  implement any instruction of the processor core. A microprogrammed approach
--  for implementing the processor core is the objective because it provides a
--  more flexible approach to the implementation, and provides an easier path to
--  upgrading the instruction set with additional instructions from the Rockwell
--  and the Western Design Center versions of the basic processor core. With an
--  F9408A MPC, a simple straight forward approach can be taken to the develop-
--  ment of the microprogrammed state machine. Without using external logic to
--  augment the operation of the F9408A, the resulting micoprogram can be limit-
--  ed to simple, single variable tests, which will result in the additional of
--  clock cycles to most operations/algorithms. This is not a limitation of the
--  F9408A MPC itself, or microprogramming in general, but of the application in
--  which the F9408A is included.
--
--  Mult-way branching in standard FSMs is natural, but is also one of the most
--  difficult design aspects of FSMs. Depending on the type of FSM being develp-
--  ed, implementing (area and speed) efficient state transition equations for
--  FSMs with many branches in many states is difficult and can be very diffi-
--  cult to test and debug. The same statement applies to microprogrammed state
--  machines, and is one reason why most MPCs have only a limited number of
--  instructions which support multi-way branching. However, microprogrammed
--  state machines are not limited by the architectural limitation imposed by
--  standard MPCs.
--
--  The M65C02 supports the reset trap, a non-maskable interrupt (NMI), a mask-
--  able interrupt, and the break instruction trap. In most cases, the two
--  interrupts are evaluated at the completion of each instruction. However, the
--  first instruction after one of these traps/interrupts is always executed. To
--  allow for this behavior to be easily implemented, BRV1 is used to initiate
--  the execution of a instruction regardless of the state of the NMI and/or IRQ
--  signals. BMW is used to test up to three signals and select the appropriate
--  action. Thus, most instructions will initiate the fetch of the next instruc-
--  tion by terminating their execution with BMW. Using a 2-way table, the BMW
--  will either complete the execution of the current instruction and the fetch
--  of the next instruction's opcode, or it will branch into the interrupt/traps
--  handler microroutine. Single cycle instructions will use BRV3 for the same
--  purpose, but implemented in a different manner. The next state for BMW is
--  either BRV1 or BRV2. BRV1 is used to complete the execution of the current
--  instruction and fetch the next instruction's opcode. BRV2 is used to capture
--  the interrupt vector and complete the execution of the current instruction.
--  Both the IRQ/NMI trap handler and the BRK handler start with a BRV2 instruc-
--  tion, which completes the current instruction and captures the PC. The BRV3
--  MPC operation performs the same function as BRV1, but the next state is
--  either the first state of the next instruction or the IRQ/NMI trap micro-
--  routine, which capture's the current instruction PC with BRV2.
--
--  The microprogram behavior is based on two assumptions: (1) external memory
--  is of a type in which the read data available is related to the address pre-
--  sented during the cycle, i.e. asynchronous, no-wait state RAM; and (2) the
--  PC control field causes the modification of the PC for the next clock cycle.
--  With these two assumptions, the microprogram starts with an unconditional
--  jump to a 2-way jump table which initiates the fetch of an instruction op-
--  code from memory, or vectors to the microprogram's interrupt handler. The
--  BRV1 instruction is used to capture and decode using ROM/RAM the fetched op-
--  code. The opcode is used directly as it is being read from memory to provide
--  to address a 256-way branch table in the microprogram ROM, and simultaneous-
--  ly a second decode ROM/RAM that provides the fixed portion of each instruc-
--  tions operation. That is, the 256-way instruction decoder built into
--  the microprogram ROM is the decoder for the variable microprogram, and the
--  second ROM is the decoder for the fixed microword. The variable micropro-
--  gram implements the control sequences necessary for an instruction from the
--  perspective of the addressing mode of the instruction, and the fixed micro-
--  program word defines the ALU operation to be performed when all operands are
--  available. The fixed microword is applied to the ALU under control of the
--  microprogram. Altogether, the number of bits required is 32 for the variable
--  microwords, and 24 for the fixed microword, or 56 bits total. (An additional
--  8 bits are included in the fixed microword, but they are simply reserved for
--  future use should that be required.) For debugging purposes, the opcode is
--  also loaded into the Instruction Register (IR), but it's not required.
--
--  Following the initial word at address 0, there are 31 microwords reserved
--  for future use. The intended use of these 31 locations is as a microprogram
--  bootloader for the remainder of the microprogram microstore, and for the
--  fixed instruction decoder ROM. Thus, at some future date, it may be possible
--  to update the microprogram ROMs dynamically from external memory or a serial
--  port.
--
--  The 2-way jump table, which is the target of the first unconditional branch,
--  is has two locations which are expected to be accessed by a BMW instruction.
--  The first location is labeled as _Nxt to signify that it is the fetch cycle
--  for the next opcode. The second location is used to initiate the interrupt
--  handler in the event that the external INT signal is asserted. An external
--  interrupt handler is expected to determine if an NMI or unmasked IRQ inter-
--  rupt should be taken. If INT is asserted, then the BRV2 instruction in the
--  second location of the jump table will capture the interrupt vector and jump
--  to the microprogram's interrupt handler.
--
--  Following the jump table are microroutines for handling specific instruc-
--  tions, or for handling specific addressing modes. The most significant 256
--  locations in the microprogram ROM/RAM constitute the initial microstate for
--  each of the 256 possible instruction opcodes. In the present implementation
--  only 177/178 of these instructions represent valid instructions. The remain-
--  der are executed as NOPs, and are reserved for future use. (The Rockwell
--  extensions use an additonal 32 of the opcodes, leaving 46 opcodes undefined.
--  Western Design Center uses all 256 of the opcodes to implement the 16-bit
--  W65C816 processor, which also provides an emulation of the 8-bit W65C02.)
--
--  A second 2-way jump table is included specifically for the RMW instructions.
--  The purpose of the microword with the BRV1 instruction is to complete the
--  execution of the current instruction, and simultaneously to fetch and decode
--  the next instruction. For most instructions, the ALU operation is performed
--  during in a terminal microstate with a BRV1 instruction which has Done and
--  Reg_WE asserted. For RMW instructions, the ALU operation initiated by the
--  Reg_WE control field occurs before the write back to memory of the computed
--  result. To use a BMW instruction to jump to the same 2-way jump table used
--  for RO or WO multicycle instructions may result in the M65C02 registers,
--  including the PSW, being written twice during a cycle. To avoid this issue,
--  a second BRV1, BRV2 2-way jump accessed by a BMW instruction is used for the
--  RMW instructions. The BRV1 microstate in the RMW jump table does not assert
--  Reg_WE. This allows a RMW instruction to complete in the same manner as
--  other multicycle instructions, and prevents any of the registers from being
--  written more than once per instruction cycle.
--
--  In implementing the microroutines, no attempt was made to combine the micro-
--  routines for various addressing modes such as Pre-Indexed and Post-Indexed
--  Data Page or Absolute that yield the same result. Therefore, the bit in the
--  fixed microword which previously identified the index register used by a
--  specific opcode has been reused for other purposes. The result of this opti-
--  mization is that all of the indexed addressing modes require separate micro-
--  routines for correct implementation. All that being the case, the implemen-
--  tation of the M65C02 microprogram uses only 256 microwords for instruction
--  decode, and an additional 79 microwords to implement the complete micropro-
--  gram. Therefore, there remain 177 microwords with which to implement addi-
--  tional instructions or capabilities such as bootloading the microprogram
--  memory. The current implementation uses approximately 1.88 microwords per
--  instruction, and this includes the 78 unimplemented/unused opcodes which the
--  M65C02 implements as NOPs. If those opcodes are not included, then a total
--  of 257 states, 178 + 79, are used to implement the M65C02 microprogram, or
--  1.444 microwords per instruction. The number of microstates per instruction
--  are a good measure of the efficiency of the implementation. For virtually
--  all instructions, the M65C02, due to its pipelined implementation, saves at
--  least one cycle per instruction when compared to the W65C02, R65C02, or the
--  original MOS6502 implementations.
--
--  The test program used for diagnostics and proofing of the implementation is
--  averaging 1.88 clock cycles per instruction. This is an improvement of more
--  than 40% over a standard implementation of the 6502 instruction set.
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--  Forked from M65C02_uPgm_V3
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--
--  No changes were implemented to the structure of the microwords in the basic
--  microprogram to accomodated the new M65C02_MPCv3 microprogram controller.
--  Instead, external changes to the M65C02_Core module allowed several of the
--  original fields to be redefined. In redefining the fields, the widths were
--  not changed and neither were their location in the microword. The single bit
--  Wait field, bit 18, was redefined as the ZP field. The single bit SC and
--  Done fields, bit 17 and 16, respectively, were redefined as the uLen[1:0]
--  field. In the previous implementation, SC and Done were used as a two bit
--  field, so replacing them with the uLen field is direct drop-in replacement.
--
--  Version three of the MPC uses dynamic microcycle length control to stretch
--  the microcycle of the M65C02 core. Microcycle length extension is required
--  when a BCD mode ADC/SBC is performed. Microcycle length extension may also
--  be required to access various types of memory.
--
--  The new MemTyp[1:0] field is expected to be used to let external logic know
--  the type of memory cycle that is being performed: program memory fetch, zero
--  page access, stack page access, or data memory access. The intent is for the
--  microprogram to let a memory controller external to the core know what the
--  next memory cycle will so that the memory controller can select between LUT
--  RAM (zero page), block RAM (stack page and internal program/data memory), or
--  external memory. Alternatively, this field can be reconfigured to directly
--  control the length of the next microcycle.
--
--  In general, it is expected that the MemTyp[1:0] field will directly connect
--  to a memory controller external to the MPC. That memory controller will set
--  the uLen[1:0] input of the core to control the microcycle controller of the
--  MPC. The current architecture of the address generator in the core makes it
--  difficult to use AO to determine whether the memory is internal or external.
--  However, the microprogram does "know" what memory type is being addressed
--  next. Thus, the microprogram can inform an external memory controller
--  whether page 0, page 1, or program/data memory is to be accessed next. Since
--  this data is only available to the microprogram, the MemTyp field can be
--  used by an memory controller outside of the core to implement address detec-
--  tion in a later state of the memory access cycle to dynamically change from
--  1 cycle distributed RAM (page 0), to 2 cycle block RAM memory with 0 wait
--  states (page 1 and internal program/data memory), or 4 cycle memory with
--  external wait state insertion (external program/data memory).
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--
--------------------------------------------------------------------------------
-- F9408A Instruction definitions
--------------------------------------------------------------------------------

RTS         .asm    0       -- Return from Subroutine
BSR         .asm    1       -- Branch to subroutine
FTCH        .asm    2       -- Fetch next instruction
BMW         .asm    3       -- Branch multi-way
BRV0        .asm    4       -- Branch via 0
BRV1        .asm    5       -- Branch via 1
BRV2        .asm    6       -- Branch via 2
BRV3        .asm    7       -- Branch via 3
BTH0        .asm    8       -- Branch if T0 is high
BTH1        .asm    9       -- Branch if T1 is high
BTH2        .asm    10      -- Branch if T2 is high
BTH3        .asm    11      -- Branch if T3 is high
BTL0        .asm    12      -- Branch if T0 is low
BTL1        .asm    13      -- Branch if T1 is low
BTL2        .asm    14      -- Branch if T2 is low
BTL3        .asm    15      -- Branch if T3 is low

--------------------------------------------------------------------------------
-- ROM ( output ) Field definitions
--------------------------------------------------------------------------------

Inst        .def    4       -- Instruction
BA          .def    9       -- Branch Address
ZP          .def    1       -- Force mod 256 Address Calculation
MemTyp      .def    2       -- Memory Access Type Control Field
NA_Cntl     .def    4       -- Next Address Control Field
PC_Cntl     .def    2       -- Program Counter Control Field
IO_Cntl     .def    2       -- I/O Cycle Control Field
DIO_Cntl    .def    2       -- Data Input/Output Demux/Mux Control Field
Stk_Cntl    .def    2       -- ALU Stack Pointer Control Field
RegWE_Cntl  .def    3       -- Register Write Enable (A, X, Y, S, P)
PSW_Cntl    .def    1       -- Asserted to Clear D and Set I in PSW

--------------------------------------------------------------------------------
-- Constant definitions
--------------------------------------------------------------------------------

--  Next Address Control Definitions

PC          .equ    0       -- NA <= PC (default)
Inc         .equ    1       -- NA <= PC  + 1
MAR         .equ    2       -- NA <= MAR + 0
Nxt         .equ    3       -- NA <= MAR + 1
Stk         .equ    4       -- NA <= SP  + 0
DPN         .equ    5       -- NA <= {  0, OP1} + 0
DPX         .equ    6       -- NA <= {  0, OP1} + {0, X}
DPY         .equ    7       -- NA <= {  0, OP1} + {0, Y}
LDA         .equ    8       -- NA <= {OP2, OP1} + 0
LDAX        .equ    14      -- NA <= {OP2, OP1} + {0, X}
LDAY        .equ    15      -- NA <= {OP2, OP1} + {0, Y}

--  Program Counter Control Field

Pls         .equ    1       -- PC <= PC + 1
Jmp         .equ    2       -- PC <= NA
Rel         .equ    3       -- PC <= PC + (CC ? {{8{DI[7]}}, DI} : 1)

--  Bus Interface Unit Definitions

WR          .equ    1       -- Bus Operand Write
RD          .equ    2       -- Bus Operand Read
IF          .equ    3       -- Bus Insruction Fetch

--  Memory Data Input Demultiplexer Definitions

ALU         .equ    0       -- M   <= DI
OP2         .equ    1       -- OP2 <= DI
OP1         .equ    2       -- OP1 <= DI
IR          .equ    3       -- IR  <= DI

--  Memory Data Output Multiplexer Definitions

--ALU         .equ    0       -- DO  <= Out
PCH         .equ    1       -- DO  <= PCH
PCL         .equ    2       -- DO  <= PCL
PSW         .equ    3       -- DO  <= PSW (P)

--  ALU Stack Operation Definitions

Psh         .equ    2       -- S <= S - 1
Pop         .equ    3       -- S <= S + 1

--  Register Write Enable Control Field Definitions

WE_A        .equ    1       -- Write Enable A
WE_X        .equ    2       -- Write Enable X
WE_Y        .equ    3       -- Write Enable Y
WE_R        .equ    4       -- Write Enable Register - write selected register
WE_S        .equ    5       -- Write Enable S
WE_P        .equ    6       -- Write Enable P
WE_M        .equ    7       -- Write Enable M(emory)

--  Miscellaneous Control Field Definitions

ISR         .equ    1       -- Assert ISR: Clear D, Set I

--------------------------------------------------------------------------------
--
--  Microprogram Controller Resources
--
--  T[0]    -   Valid - ALU Operation Complete/Done
--  T[1]    -   Unused
--  T[2]    -   Unused
--  T[3]    -   Unused
--
--  Via[0]  -   BA, but also waits for the completion of a memory or ALU cycle
--  Via[1]  -   Instruction Decoder, effectively functions as a 256 way branch
--  Via[2]  -   Samples Vector and loads it into {OP2, OP1}
--  Via[3]  -   Instruction Decoder with branch to Interrupt Handler, _Int
--
--  MW[2:0] -   MW[2] - uP_BA[2]; MW[1] - uP_BA[1]; MW[0] - Int;
--
--   xx0    -   Instruction Fetch
--   xx1    -   Interrupt Trap
--
--------------------------------------------------------------------------------
-- MAM6502 Microprogram Start
--------------------------------------------------------------------------------

--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR

_Start: .org    0
    BRV2    _Rst,0,1                            -- Load {OP2, OP1} with Vector
_Rst:
    FTCH    $,0,1, LDA,, RD, OP1                -- Read Indirect Dst Ptr Lo
    FTCH    $,0,1, Nxt, Jmp, RD, OP2            -- Read Indirect Dst Ptr Hi
--
    BRV1    $,0,1,, Pls, IF, IR                 -- Instruction Fetch

--  this space reserved for future use - boot loader for the microprogram ROMs

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- 2-Way Jump Table: _Nxt and _Int
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- Instruction Fetch and Execute Microstate
--------------------------------------------------------------------------------

_Nxt:   .org    32
_Psh:
_Pop:
_Rel:
_Imm:
    BRV1    _Nxt,0,1,, Pls, IF, IR,, WE_R           -- Instruction Fetch/Execute

--------------------------------------------------------------------------------
--  Interrupt Entry - NMI, (unmasked) IRQ (falls through to second state of BRK)
--------------------------------------------------------------------------------

_Int:
    BRV2    _Brk,0,1, Stk,, WR, PCH, Psh, WE_R      -- Push PCH, capture Vector

--------------------------------------------------------------------------------
--  BRK Entry - BRK #imm (_Int falls through to _Brk, see comment above)
--------------------------------------------------------------------------------

_Brk:
    FTCH    $,0,1, Stk,, WR, PCL, Psh               -- Push PCL
    FTCH    $,0,1, Stk, Jmp, WR, PSW, Psh,, ISR     -- Push P; Clr D, Set I
--
    FTCH    $,0,1, LDA,, RD, OP1                    -- Read Indirect Dst Ptr Lo
    FTCH    $,0,1, Nxt, Jmp, RD, OP2                -- Read Indirect Dst Ptr Hi
--
    BRV1    $,0,1,, Pls, IF, IR                     -- Instruction Fetch

--------------------------------------------------------------------------------
--  Jump To Subroutine - JSR Abs                    (Not interruptable)
--------------------------------------------------------------------------------

_JSR:
    FTCH    $,0,1,,, IF, OP2                        -- Load Indirect Dst Ptr Hi
    FTCH    $,0,1, Stk,, WR, PCH, Psh               -- Push PC Hi
    BRV0    _Nxt,0,1, Stk, Jmp, WR, PCL, Psh        -- Push PC Lo

--------------------------------------------------------------------------------
--  Return from Interrupt - RTI                     (Not interruptable)
--------------------------------------------------------------------------------

_RTI:
    FTCH    $,0,1, Stk,, RD, OP1, Pop, WE_P         -- Pop PCL
    FTCH    $,0,1, Stk, Jmp, RD, OP2, Pop           -- Pop PCH
--
    BRV1    $,0,1,, Pls, IF, IR                     -- Next, no Reg_WE, P okay

--------------------------------------------------------------------------------
--  Return From Subroutine - RTS                    (Not interruptable)
--------------------------------------------------------------------------------

_RTS:
    BRV0    _Nxt,0,1, Stk, Jmp, RD, OP2, Pop        -- Pop PCH

--------------------------------------------------------------------------------
--  Jump Absolute - JMP  Abs                        (Not interruptable)
--------------------------------------------------------------------------------

_Jmp:
    BRV0    _Nxt,0,1,, Jmp, IF, OP2

--------------------------------------------------------------------------------
--  Jump Indirect - JMP (Abs)                       (Not interruptable)
--------------------------------------------------------------------------------

_JmpI:
    FTCH    $,0,1,, Pls, IF, OP2                    -- Load Indirect Dst Ptr Lo
    FTCH    $,0,1, LDA,, RD, OP1                    -- Read Indirect Dst Ptr Hi
    BRV0    _Nxt,0,1, Nxt, Jmp, RD, OP2             -- Goto Next

--------------------------------------------------------------------------------
--  Jump Pre-Indexed Indirect - JMP (Abs, X)       (Not interruptable)
--------------------------------------------------------------------------------

_JmpXI:
    FTCH    $,0,1,, Pls, IF, OP2                    -- Load Indirect Dst Ptr Lo
    FTCH    $,0,1, LDAX,, RD, OP1                   -- Read Indirect Dst Ptr Hi
    BRV0    _Nxt,0,1, Nxt, Jmp, RD, OP2             -- Goto Next

--------------------------------------------------------------------------------
--  Memory Read-Only Data Page Direct - xxx DP
--------------------------------------------------------------------------------

_RO_DP:
    BMW     _Nxt,1,1, DPN,, RD, OP1                     -- Read DP Mem

-----------------------------------------------------------------------------
--  Memory Read-Only Pre-Indexed Data Page Direct - xxx DP, X
--------------------------------------------------------------------------------

_RO_DPX:
    BMW     _Nxt,1,1, DPX,, RD, OP1                     -- Read DP Mem

--------------------------------------------------------------------------------
--  Memory Read-Only Post-Indexed Data Page Direct - xxx DP, Y
--------------------------------------------------------------------------------

_RO_DPY:
    BMW     _Nxt,1,1, DPY,, RD, OP1                     -- Read DP Mem

------------------------------------------------------------------------------
--  Memory Read-Only Data Page Indirect - xxx (DP)
--------------------------------------------------------------------------------

_RO_DPI:
    FTCH    $,1,1, DPN,, RD, OP1                        -- Read DP Mem Ptr Lo
    FTCH    $,1,1, Nxt,, RD, OP2                        -- Read DP Mem Ptr Hi
    BMW     _Nxt,0,1, LDA,, RD, OP1                     -- Read Operand

--------------------------------------------------------------------------------
--  Memory Read-Only Pre-Indexed Data Page Indirect - xxx (DP, X)
--------------------------------------------------------------------------------

_RO_DPXI:
    FTCH    $,1,1, DPX,, RD, OP1                    -- Read DP Mem Ptr Lo (DP,X)
    FTCH    $,1,1, Nxt,, RD, OP2                        -- Read DP Mem Ptr Hi
    BMW     _Nxt,0,1, LDA,, RD, OP1                     -- Read Operand

--------------------------------------------------------------------------------
--  Memory Read-Only Post-Indexed Data Page Indirect - xxx (DP), Y
--------------------------------------------------------------------------------

_RO_DPIY:
    FTCH    $,1,1, DPN,, RD, OP1                        -- Read DP Mem Ptr Lo
    FTCH    $,1,1, Nxt,, RD, OP2                        -- Read DP Mem Ptr Hi
    BMW     _Nxt,0,1, LDAY,, RD, OP1                    -- Read Operand (DP),Y

--------------------------------------------------------------------------------
--  Memory Read-Only Absolute - xxx Abs
--------------------------------------------------------------------------------

_RO_Abs:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    BMW     _Nxt,0,1, LDA,, RD, OP1                     -- Read Operand

--------------------------------------------------------------------------------
--  Memory Read-Only Pre-Indexed Absolute - xxx Abs, X
--------------------------------------------------------------------------------

_RO_AbsX:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    BMW     _Nxt,0,1, LDAX,, RD, OP1                    -- Read Operand Abs,X

--------------------------------------------------------------------------------
--  Memory Read-Only Post-Indexed Absolute - xxx Abs, Y
--------------------------------------------------------------------------------

_RO_AbsY:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    BMW     _Nxt,0,1, LDAY,, RD, OP1                    -- Read Operand Abs,Y

--------------------------------------------------------------------------------
--  Memory Write-Only Data Page Direct - xxx DP
--------------------------------------------------------------------------------

_WO_DP:
    BMW     _Nxt,1,1, DPN,, WR                          -- Write to DP

-----------------------------------------------------------------------------
--  Memory Write-Only Pre-Indexed Data Page Direct - xxx DP, X
--------------------------------------------------------------------------------

_WO_DPX:
    BMW    _Nxt,1,1, DPX,, WR                          -- Write to DP,X

-----------------------------------------------------------------------------
--  Memory Write-Only Post-Indexed Data Page Direct - xxx DP, Y
--------------------------------------------------------------------------------

_WO_DPY:
    BMW     _Nxt,1,1, DPY,, WR                          -- Write to DP,Y

--------------------------------------------------------------------------------
--  Memory Write-Only Data Page Indirect - xxx (DP)
--------------------------------------------------------------------------------

_WO_DPI:
    FTCH    $,1,1, DPN,, RD, OP1                        -- Read DP Mem Ptr Lo
    FTCH    $,1,1, Nxt,, RD, OP2                        -- Read DP Mem Ptr Hi
    BMW     _Nxt,0,1, LDA,, WR                          -- Write to (DP)

--------------------------------------------------------------------------------
--  Memory Write-Only Data Page Indirect - xxx (DP, X)
--------------------------------------------------------------------------------

_WO_DPXI:
    FTCH    $,1,1, DPX,, RD, OP1                        -- Read DP Mem Ptr Lo
    FTCH    $,1,1, Nxt,, RD, OP2                        -- Read DP Mem Ptr Hi
    BMW     _Nxt,0,1, LDA,, WR                          -- Write to (DP)

--------------------------------------------------------------------------------
--  Memory Write-Only Post-Indexed Data Page Indirect - xxx (DP), Y
--------------------------------------------------------------------------------

_WO_DPIY:
    FTCH    $,1,1, DPN,, RD, OP1                        -- Read DP Mem Ptr Lo
    FTCH    $,1,1, Nxt,, RD, OP2                        -- Read DP Mem Ptr Hi
    BMW     _Nxt,0,1, LDAY,, WR                         -- Write to (DP)

--------------------------------------------------------------------------------
--  Memory Write-Only Absolute - xxx Abs
--------------------------------------------------------------------------------

_WO_Abs:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    BMW     _Nxt,0,1, LDA,, WR                          -- Write to Abs

--------------------------------------------------------------------------------
--  Memory Write-Only Pre-Indexed Absolute - xxx Abs, X
--------------------------------------------------------------------------------

_WO_AbsX:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    BMW     _Nxt,0,1, LDAX,, WR                         -- Write to Abs,X

--------------------------------------------------------------------------------
--  Memory Write-Only Post-Indexed Absolute - xxx Abs, Y
--------------------------------------------------------------------------------

_WO_AbsY:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    BMW     _Nxt,0,1, LDAY,, WR                         -- Write to Abs,Y

--------------------------------------------------------------------------------
--  2-way Read-Modify-Write Instruction/Interrupt Jump Table
--------------------------------------------------------------------------------

_RMW:       .org    96
    BRV1    _RMW,0,1,, Pls, IF, IR                  -- Instruction Fetch/Execute
    BRV2    _Brk,0,1, Stk, , WR, PCH, Psh           -- Push PCH, capture Vector

--------------------------------------------------------------------------------
--  Memory Read-Modify-Write Data Page Direct - xxx DP
--------------------------------------------------------------------------------

_RMW_DP:
    FTCH    $,1,1, DPN,, RD, OP1                        -- Read from DP
    BMW     _RMW,1,1, MAR,, WR,,,WE_R                   -- Write to DP

--------------------------------------------------------------------------------
--  Memory Read-Modify-Write Pre-Indexed Data Page Direct - xxx DP, X
--------------------------------------------------------------------------------

_RMW_DPX:
    FTCH    $,1,1, DPX,, RD, OP1                        -- Read from DP,X
    BMW     _RMW,1,1, MAR,, WR,,,WE_R                   -- Write to DP,X

--------------------------------------------------------------------------------
--  Memory Read-Modify-Write Post-Indexed Data Page Direct - xxx DP, Y
--------------------------------------------------------------------------------

_RMW_DPY:
    FTCH    $,1,1, DPY,, RD, OP1                        -- Read from DP,Y
    BMW     _RMW,1,1, MAR,, WR,,,WE_R                   -- Write to DP,Y

--------------------------------------------------------------------------------
--  Memory Read-Modify-Write Absolute - xxx Abs
--------------------------------------------------------------------------------

_RMW_Abs:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    FTCH    $,0,1, LDA,, RD, OP1                        -- Read from Abs
    BMW     _RMW,0,1, MAR,, WR,,,WE_R                   -- Write to Abs

--------------------------------------------------------------------------------
--  Memory Read-Modify-Write Pre-Indexed Absolute - xxx Abs, X
--------------------------------------------------------------------------------

_RMW_AbsX:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    FTCH    $,0,1, LDAX,, RD, OP1                       -- Read from Abs,X
    BMW     _RMW,0,1, MAR,, WR,,,WE_R                   -- Write to Abs,X

--------------------------------------------------------------------------------
--  Memory Read-Modify-Write Post-Indexed Absolute - xxx Abs, Y
--------------------------------------------------------------------------------

_RMW_AbsY:
    FTCH    $,0,1,, Pls, IF, OP2                        -- Read Mem Ptr Hi
    FTCH    $,0,1, LDAY,, RD, OP1                       -- Read from Abs,Y
    BMW     _RMW,0,1, MAR,, WR,,,WE_R                   -- Write to Abs,Y

--------------------------------------------------------------------------------
--  Rockwell BBRx/BBSx dp,rel instructions
--------------------------------------------------------------------------------

_BByx_dp_rel:
    FTCH    $,1,1, DPN,, RD, OP1                        -- Read from DP
    BRV0    _Nxt,0,1,, Rel, IF, OP1                     -- Read rel value

--------------------------------------------------------------------------------
--  End of Microprogram Routines for Normal Instructions
--------------------------------------------------------------------------------

_End_uPgm:

--------------------------------------------------------------------------------
--  WAI - Wait for Interrupt
--------------------------------------------------------------------------------

_WAI:       .org    252     -- Set up 4-way table for WAI instruction
    BMW     _WAI,0,1        -- No external interrupts asserted
    BRV0    _Int,0,1        -- Int asserted by NMI, do NMI interrupt
    BRV0    _Nxt,0,1        -- xIRQ asserted with IRQ_Msk asserted, continue
    BRV0    _Int,0,1        -- Int asserted by xIRQ, do IRQ interrupt

_IDEC_Start:    .org    256

--------------------------------------------------------------------------------
--  Start of Instruction Decode Table (Entry for each Opcode)
--
--  Instead of being organized in numerical order, the table is organized by
--  rows: the least significant nibble and the most significant nibble of the
--  opcode are swapped. This organization more clearly shows the arrangement of
--  the addressing modes of the WDC W65C02 microprocessor being emulated. It al-
--  so more clearly shows the regularity of the ALU instructions that are imple-
--  mented. The implementation of the microprogram is first based on the addres-
--  sing mode, and then on the ALU function. Single cycle instructions will be
--  easily recognized in the following table because their table entry use the
--  BRV3 MPC instruction. Multi-cycle instructions use the BRV0 MPC instruction
--  to vector a microroutine in the lower 256 words of the microprogram ROM/RAM.
--  Single byte instructions such as BRK, RTS, RTI, and register push/pull in-
--  structions (PHA, PLA, PHP, PLP, PHX, PLX, PHY, PLY), and multi-byte instruc-
--  tions like JSR abs are implemented with special microroutines that perform
--  the necessary stack accesses. The remainder of the microroutines are orga-
--  nized by addressing mode, and whether the mode is used in a RO, WO, or RMW
--  manner.
--
--  Microprogram Word Format:
--
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--  Row 0 : 0x00-0xF0 (All Bcc/JMP/JSR/RTS/RTI implemented as uninterruptable)
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_BRK_imm:
    BRV2    _Brk,0,1, Stk,, WR, PCH, Psh, WE_P      -- Start Break Handler
_BPL_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_JSR_abs:
    BRV0    _JSR,0,1,, Pls, IF, OP1                 -- Read Dst Ptr Lo
_BMI_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_RTI_imp:
    BRV0    _RTI,0,1, Stk,, RD, OP1, Pop            -- Read PSW from Stack
_BVC_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_RTS_imp:
    BRV0    _RTS,0,1, Stk,, RD, OP1, Pop            -- Read PCL from Stack
_BVS_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_BRA_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_BCC_rel
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_LDY_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read #imm Value
_BCS_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_CPY_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read #imm Value
_BNE_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
_CPX_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read #imm Value
_BEQ_rel:
    BRV0    _Rel,0,1,, Rel, IF, OP1                 -- Read rel Value
--------------------------------------------------------------------------------
-- Row 1 : 0x01-0xF1
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ORA_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_ORA_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_AND_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_AND_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_EOR_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_EOR_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_ADC_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_ADC_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_STA_dpXi:
    BRV0    _WO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_STA_dpiY:
    BRV0    _WO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_LDA_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_LDA_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_CMP_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_CMP_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
_SBC_dpXi:
    BRV0    _RO_DPXI,0,1,, Pls, IF, OP1             -- Read DP Ptr
_SBC_dpiY:
    BRV0    _RO_DPIY,0,1,, Pls, IF, OP1             -- Read DP Ptr
--------------------------------------------------------------------------------
-- Row 2 : 0x02-0xF2
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_NOP_02:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_ORA_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_NOP_22:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_AND_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_NOP_42:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_EOR_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_NOP_62:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_ADC_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_NOP_82:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_STA_dpi:
    BRV0    _WO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_LDX_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read #imm Value
_LDA_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_NOP_C2:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_CMP_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
_NOP_E2:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_SBC_dpi:
    BRV0    _RO_DPI,0,1,, Pls, IF, OP1              -- Read DP
--------------------------------------------------------------------------------
-- Row 3 : 0x03-0xF3
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_NOP_03:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_13:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_23:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_33:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_43:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_53:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_63:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_73:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_83:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_93:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_A3:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_B3:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_C3:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_D3:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_E3:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_F3:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
--------------------------------------------------------------------------------
-- Row 4 : 0x04-0xF4
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_TSB_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_TRB_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_BIT_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_BIT_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_NOP_44:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_54:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_STZ_dp:
    BRV0    _WO_DP,0,1,, Pls, IF, OP1               -- Read DP
_STZ_dpX:
    BRV0    _WO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_STY_dp:
    BRV0    _WO_DP,0,1,, Pls, IF, OP1               -- Read DP
_STY_dpX:
    BRV0    _WO_DPX,0,1,, Pls, IR, OP1              -- Read DP
_LDY_dp:
    BRV0    _RO_DP,0,1,, Pls, IR, OP1               -- Read DP
_LDY_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_CPY_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_NOP_D4:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_CPX_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_NOP_F4:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
--------------------------------------------------------------------------------
-- Row 5 : 0x05-0xF5
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ORA_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_ORA_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_AND_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_AND_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_EOR_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_EOR_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_ADC_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_ADC_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_STA_dp:
    BRV0    _WO_DP,0,1,, Pls, IF, OP1               -- Read DP
_STA_dpX:
    BRV0    _WO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_LDA_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_LDA_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_CMP_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_CMP_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
_SBC_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_SBC_dpX:
    BRV0    _RO_DPX,0,1,, Pls, IF, OP1              -- Read DP
--------------------------------------------------------------------------------
-- Row 6 : 0x06-0xF6
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ASL_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_ASL_dpX:
    BRV0    _RMW_DPX,0,1,, Pls, IF, OP1             -- Read DP
_ROL_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_ROL_dpX:
    BRV0    _RMW_DPX,0,1,, Pls, IF, OP1             -- Read DP
_LSR_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_LSR_dpX:
    BRV0    _RMW_DPX,0,1,, Pls, IF, OP1             -- Read DP
_ROR_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_ROR_dpX:
    BRV0    _RMW_DPX,0,1,, Pls, IF, OP1             -- Read DP
_STX_dp:
    BRV0    _WO_DP,0,1,, Pls, IF, OP1               -- Read DP
_STX_dpY:
    BRV0    _WO_DPY,0,1,, Pls, IF, OP1              -- Read DP
_LDX_dp:
    BRV0    _RO_DP,0,1,, Pls, IF, OP1               -- Read DP
_LDX_dpY:
    BRV0    _RO_DPY,0,1,, Pls, IF, OP1              -- Read DP
_DEC_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_DEC_dpX:
    BRV0    _RMW_DPX,0,1,, Pls, IF, OP1             -- Read DP
_INC_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_INC_dpX:
    BRV0    _RMW_DPX,0,1,, Pls, IF, OP1             -- Read DP
--------------------------------------------------------------------------------
-- Row 7 : 0x07-0xF7 (Rockwell Instructions: RMBx/SMBx dp)
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_RMB0_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB1_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB2_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB3_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB4_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB5_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB6_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_RMB7_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB0_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB1_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB2_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB3_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB4_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB5_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB6_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
_SMB7_dp:
    BRV0    _RMW_DP,0,1,, Pls, IF, OP1              -- Read DP
--------------------------------------------------------------------------------
-- Row 8 : 0x08-0xF8
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_PHP:
    BRV0    _Psh,0,1, Stk,, WR,, Psh                -- Push P
_CLC:
    BRV3    $,0,1,, Pls, IF, IR,, WE_P              -- Clear Carry Flag
_PLP:
    BRV0    _Pop,0,1, Stk,, RD, OP1, Pop            -- Pop P
_SEC:
    BRV3    $,0,1,, Pls, IF, IR,, WE_P              -- Set Carry Flag
_PHA:
    BRV0    _Psh,0,1, Stk,, WR,, Psh                -- Push A
_CLI:
    BRV1    $,0,1,, Pls, IF, IR,, WE_P              -- Clear Interrupt Mask Flg
_PLA:
    BRV0    _Pop,0,1, Stk,, RD, OP1, Pop            -- Pop A
_SEI:
    BRV1    $,0,1,, Pls, IF, IR,, WE_P              -- Set Interrupt Mask Flag
_DEY:
    BRV3    $,0,1,, Pls, IF, IR,, WE_Y              -- Decrement Y
_TYA:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Transfer Y to A
_TAY:
    BRV3    $,0,1,, Pls, IF, IR,, WE_Y              -- Transfer A to Y
_CLV:
    BRV3    $,0,1,, Pls, IF, IR,, WE_P              -- Clear oVerflow Flag
_INY:
    BRV3    $,0,1,, Pls, IF, IR,, WE_Y              -- Increment Y
_CLD:
    BRV3    $,0,1,, Pls, IF, IR,, WE_P              -- Clear Decimal Mode Flag
_INX:
    BRV3    $,0,1,, Pls, IF, IR,, WE_X              -- Increment X
_SED:
    BRV3    $,0,1,, Pls, IF, IR,, WE_P              -- Set Decimal Mode Flag
--------------------------------------------------------------------------------
-- Row 9 : 0x09-0xF9
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ORA_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_ORA_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_AND_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_AND_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_EOR_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_EOR_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_ADC_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_ADC_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_BIT_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_STA_absY:
    BRV0    _WO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_LDA_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_LDA_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_CMP_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_CMP_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
_SBC_imm:
    BMW     _Imm,0,1,, Pls, IF, OP1                 -- Read Immediate Operand
_SBC_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Mem Ptr Lo
--------------------------------------------------------------------------------
-- Row A : 0x0A-0xFA
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ASL_A:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Arithmetic Shift A Left
_INC_A:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Increment A
_ROL_A:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Rotate A Left
_DEC_A:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Decrement A
_LSR_A:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Logical Shift A Right
_PHY:
    BRV0    _Psh,0,1, Stk,, WR,, Psh                -- Push Y
_ROR_A:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Rotate A Right
_PLY:
    BRV0    _Pop,0,1, Stk,, RD, OP1, Pop            -- Pop Y
_TXA:
    BRV3    $,0,1,, Pls, IF, IR,, WE_A              -- Transfer X to A
_TXS:
    BRV3    $,0,1,, Pls, IF, IR,, WE_S              -- Transfer X to S
_TAX:
    BRV3    $,0,1,, Pls, IF, IR,, WE_X              -- Transfer A to X
_TSX:
    BRV3    $,0,1,, Pls, IF, IR,, WE_X              -- Transfer S to X
_DEX:
    BRV3    $,0,1,, Pls, IF, IR,, WE_X              -- Decrement X
_PHX:
    BRV0    _Psh,0,1, Stk,, WR,, Psh                -- Push X
_NOP:   -- the real NOP
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip True NOP Instruction
_PLX:
    BRV0    _Pop,0,1, Stk,, RD, OP1, Pop            -- Pop X
--------------------------------------------------------------------------------
-- Row B : 0x0B-0xFB
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_NOP_0B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_1B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_2B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_3B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_4B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_5B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_6B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_7B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_8B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_9B:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_AB:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_BB:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_WAI_CB:
    BRV0    _WAI,0,1                                -- Wait for Interrupt
_STP_DB:
    BRV0    $,0,1                                   -- Stop Processor Execution
_NOP_EB:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_NOP_FB:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
--------------------------------------------------------------------------------
-- Row C : 0x0C-0xFC
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_TSB_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_TRB_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_BIT_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_BIT_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_JMP_abs:
    BRV0    _Jmp,0,1,, Pls, IF, OP1                 -- Read Dst Ptr Lo
_NOP_5C:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_JMP_absi:
    BRV0    _JmpI,0,1,, Pls, IF, OP1                -- Read Dst Ptr Lo
_JMP_absXi:
    BRV0    _JmpXI,0,1,, Pls, IF, OP1               -- Read Dst Ptr Lo
_STY_abs:
    BRV0    _WO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_STZ_abs:
    BRV0    _WO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_LDY_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_LDY_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_CPY_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_NOP_DC:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
_CPX_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_NOP_FC:
    BRV3    $,0,1,, Pls, IF, IR                     -- Skip Invalid Instruction
--------------------------------------------------------------------------------
-- Row D : 0x0D-0xFD
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ORA_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_ORA_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_AND_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_AND_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_EOR_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_EOR_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_ADC_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_ADC_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_STA_abs:
    BRV0    _WO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_STA_absX:
    BRV0    _WO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_LDA_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_LDA_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_CMP_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_CMP_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_SBC_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_SBC_absX:
    BRV0    _RO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
--------------------------------------------------------------------------------
-- Row E : 0x0E-0xFE
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_ASL_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_ASL_absX:
    BRV0    _RMW_AbsX,0,1,, Pls, IF, OP1            -- Read Dst Ptr Lo
_ROL_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_ROL_absX:
    BRV0    _RMW_AbsX,0,1,, Pls, IF, OP1            -- Read Dst Ptr Lo
_LSR_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_LSR_absX:
    BRV0    _RMW_AbsX,0,1,, Pls, IF, OP1            -- Read Dst Ptr Lo
_ROR_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_ROR_absX:
    BRV0    _RMW_AbsX,0,1,, Pls, IF, OP1            -- Read Dst Ptr Lo
_STX_abs:
    BRV0    _WO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_STZ_absX:
    BRV0    _WO_AbsX,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_LDX_abs:
    BRV0    _RO_Abs,0,1,, Pls, IF, OP1              -- Read Dst Ptr Lo
_LDX_absY:
    BRV0    _RO_AbsY,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_DEC_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_DEC_absX:
    BRV0    _RMW_AbsX,0,1,, Pls, IF, OP1            -- Read Dst Ptr Lo
_INC_abs:
    BRV0    _RMW_Abs,0,1,, Pls, IF, OP1             -- Read Dst Ptr Lo
_INC_absX:
    BRV0    _RMW_AbsX,0,1,, Pls, IF, OP1            -- Read Dst Ptr Lo
--------------------------------------------------------------------------------
-- Row F : 0x0F-0xFF (Rockwell Instructions: BBRx/BBSx dp,rel)
--  I   BA, Wt, En, NA, PC, IO, DI, SP, Reg_WE, ISR
--------------------------------------------------------------------------------
_BBR0_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR1_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR2_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR3_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR4_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR5_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR6_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBR7_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS0_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS1_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS2_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS3_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS4_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS5_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS6_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
_BBS7_dp_rel:
    BRV0    _BByx_dp_rel,0,1,, Pls, IF, OP1         -- Read DP
--------------------------------------------------------------------------------
--  End of Instruction Decode Table
--------------------------------------------------------------------------------

_Last:  .org 512

_end:
